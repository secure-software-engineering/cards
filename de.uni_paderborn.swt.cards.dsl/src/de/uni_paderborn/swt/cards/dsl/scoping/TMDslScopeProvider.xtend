/*
 * generated by Xtext 2.18.0.M3
 */
package de.uni_paderborn.swt.cards.dsl.scoping

import de.uni_paderborn.swt.cards.dsl.tmdsl.AllowGroupRestriction
import de.uni_paderborn.swt.cards.dsl.tmdsl.Component
import de.uni_paderborn.swt.cards.dsl.tmdsl.ComponentAssumption
import de.uni_paderborn.swt.cards.dsl.tmdsl.ComponentFlowAssumption
import de.uni_paderborn.swt.cards.dsl.tmdsl.ComponentFlowSanitizationAssumption
import de.uni_paderborn.swt.cards.dsl.tmdsl.ComponentGroup
import de.uni_paderborn.swt.cards.dsl.tmdsl.ComponentGroupAllowRefinement
import de.uni_paderborn.swt.cards.dsl.tmdsl.ComponentGroupPreventRefinement
import de.uni_paderborn.swt.cards.dsl.tmdsl.ComponentKind
import de.uni_paderborn.swt.cards.dsl.tmdsl.ComponentPart
import de.uni_paderborn.swt.cards.dsl.tmdsl.ComponentSanitizerAssumption
import de.uni_paderborn.swt.cards.dsl.tmdsl.CompositeComponent
import de.uni_paderborn.swt.cards.dsl.tmdsl.DataGroup
import de.uni_paderborn.swt.cards.dsl.tmdsl.DataType
import de.uni_paderborn.swt.cards.dsl.tmdsl.Groups
import de.uni_paderborn.swt.cards.dsl.tmdsl.Model
import de.uni_paderborn.swt.cards.dsl.tmdsl.Port
import de.uni_paderborn.swt.cards.dsl.tmdsl.PortAssumption
import de.uni_paderborn.swt.cards.dsl.tmdsl.PortConnector
import de.uni_paderborn.swt.cards.dsl.tmdsl.PortGroup
import de.uni_paderborn.swt.cards.dsl.tmdsl.PortMapping
import de.uni_paderborn.swt.cards.dsl.tmdsl.PortPart
import de.uni_paderborn.swt.cards.dsl.tmdsl.PortSanitizerAssumption
import de.uni_paderborn.swt.cards.dsl.tmdsl.PreventGroupRestriction
import de.uni_paderborn.swt.cards.dsl.tmdsl.Sanitizer
import de.uni_paderborn.swt.cards.dsl.tmdsl.TmdslPackage
import de.uni_paderborn.swt.cards.dsl.tmdsl.impl.AllowGroupRestrictionImpl
import de.uni_paderborn.swt.cards.dsl.tmdsl.impl.PreventGroupRestrictionImpl
import java.util.ArrayList
import java.util.stream.Collectors
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.scoping.Scopes

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class TMDslScopeProvider extends AbstractTMDslScopeProvider {


	override getScope(EObject context, EReference reference) {
		
		val rootContainer = EcoreUtil2.getRootContainer(context) as Model
		val system = rootContainer.system
		val dataGroups = EcoreUtil2.getAllContentsOfType(rootContainer, DataGroup)
		
		
		if (context instanceof de.uni_paderborn.swt.cards.dsl.tmdsl.System) {
			if (reference == TmdslPackage.Literals.DATA_TYPE__LABELS) {
				val labels = system.dataLabels
				return Scopes.scopeFor(labels);
			}
		}
		
		//Connector Scopes --> Allow only connection of ports of different components
		if (context instanceof PortConnector) {
			val connector = context as PortConnector
			val parentComponent = connector.eContainer as CompositeComponent
			val availableParts = parentComponent.componentParts
			
			if (reference ==TmdslPackage.Literals.PORT_CONNECTOR__SOURCE_PART){
				return Scopes.scopeFor(availableParts)
			}
			if (reference ==TmdslPackage.Literals.PORT_CONNECTOR__TARGET_PART){
				//only allow connections to different components
				val availablePartsDup = new ArrayList<ComponentPart>()
				availablePartsDup.addAll(availableParts)
				availablePartsDup.remove(connector.sourcePart)
				
				//TODO: add this
//				//only show parts with compatible port
//				val portType = connector.source.getPortType();
//				if (portType != PortType.INOUT) {
//					for (ComponentPart part : availableParts){
//						var hasCompatiblePort = false
//
//						for (Port port : part.component.ports) {
//							if (port.getPortType() == PortType.INOUT || port.getPortType() != portType) {
//								hasCompatiblePort = true
//							}
//						}
//						
//						//remove incompatible parts
//						if (!hasCompatiblePort)
//							availablePartsDup.remove(part)
//					}
//				}

				
				return Scopes.scopeFor(availablePartsDup)
			}
			if (reference == TmdslPackage.Literals.PORT_CONNECTOR__SOURCE){
				val availablePorts = connector.sourcePart.portParts
				return Scopes.scopeFor(availablePorts)
			}
			if (reference == TmdslPackage.Literals.PORT_CONNECTOR__TARGET){
				val availablePorts = connector.targetPart.portParts
				val availablePortsDup = new ArrayList<PortPart>()
				availablePortsDup.addAll(availablePorts);
				
				//TODO add this
//				if (connector.source.getPortType() != PortType.INOUT) {
//					for(Port p : availablePorts) {
//						if (p.getPortType() == connector.source.getPortType())
//							availablePortsDup.remove(p)
//					}
//				}
				
				return Scopes.scopeFor(availablePortsDup)	
			}	
		}
		
		if (context instanceof PortMapping) {
			val mapping = context as PortMapping
			val parentComponent = mapping.eContainer as CompositeComponent
			val availableParts = parentComponent.componentParts
			
			if (reference == TmdslPackage.Literals.PORT_MAPPING__SOURCE) {
				val ports = parentComponent.ports
				return Scopes.scopeFor(ports)
			}
			
			if (reference == TmdslPackage.Literals.PORT_MAPPING__TARGET_PART) {
				return Scopes.scopeFor(availableParts)
			}
			
			if (reference == TmdslPackage.Literals.PORT_MAPPING__TARGET) {
				val ports = mapping.targetPart.portParts
				val portsDup = new ArrayList<PortPart>()
				portsDup.addAll(ports)
				
//				for(Port p : ports) {
//					if (p.portType != mapping.source.portType && p.portType != PortType.INOUT) {
//						portsDup.remove(p)
//					}
//				}
				
				return Scopes.scopeFor(portsDup)
			}
		}
		
		
		if (context instanceof DataGroup){			
			if (reference == TmdslPackage.Literals.DATA_GROUP__GROUPED_DATA) {
				val dts = EcoreUtil2.getAllContentsOfType(system, DataType)
				
				return Scopes.scopeFor(dts)
			}
		}
		if (context instanceof ComponentGroup){			
			if (reference == TmdslPackage.Literals.COMPONENT_GROUP__GROUPED_COMPONENTS) {
				val cts = EcoreUtil2.getAllContentsOfType(system, Component)
				//cts.removeAll((context as ComponentGroup).groupedComponents)
				return Scopes.scopeFor(cts)
			}
		}
		if (context instanceof PortGroup){
			if (reference == TmdslPackage.Literals.PORT_GROUP__GROUPED_PORTS) {
				val pts = EcoreUtil2.getAllContentsOfType(system, Port)
				//pts.removeAll((context as PortGroup).groupedPorts)
				return Scopes.scopeFor(pts)
			}
		}
		
		
		if (context instanceof AllowGroupRestriction){
			
			//get scope for group data parameter
			if (reference == TmdslPackage.Literals.ALLOW_GROUP_RESTRICTION__GROUP_ASSET) {
				//get all available data groups
				val availableDataGroups = dataGroups
				//get all PreventGroupRestriction objects
//				val preventRestrictions = EcoreUtil2.getAllContentsOfType(rootContainer, PreventGroupRestriction)
//				//get all data groups
//				//TODO: use something similar to collect() from OCL?
//				val preventGroups = new ArrayList<DataGroup>
//				for (pr : preventRestrictions){
//					val groups2Add = pr.groupAsset
//					preventGroups.addAll(groups2Add)
//				}
//				//remove all data groups already used in PreventGroupRestrictions
//				availableDataGroups.removeAll(preventGroups)
				
				return Scopes.scopeFor(availableDataGroups)
				
			}
			
			
		}
		
		if (context instanceof PreventGroupRestriction){
			
			//get scope for group data parameter
			if (reference == TmdslPackage.Literals.PREVENT_GROUP_RESTRICTION__GROUP_ASSET) {
				//get all available data groups
				val availableDataGroups = dataGroups
				//get all AllowGroupRestriction objects
//				val allowRestrictions = EcoreUtil2.getAllContentsOfType(rootContainer, AllowGroupRestriction)
//				//get all data groups
//				//TODO: use something similar to collect() from OCL?
//				val allowGroups = new ArrayList<DataGroup>
//				for (ar : allowRestrictions){
//					val groups2Add = ar.groupAsset
//					allowGroups.addAll(groups2Add)
//				}
//				//remove all data groups already used in AllowGroupRestrictions
//				availableDataGroups.removeAll(allowGroups)
				
				return Scopes.scopeFor(availableDataGroups)
				
			}
			
		}
		
		/////////////////
		//PREVENT RESTRICIONTS
		//return data types for prevent restrictions
		if (reference == TmdslPackage.Literals.COMPONENT_ALLOW_REFINEMENT__DATA_ASSET ||
			reference == TmdslPackage.Literals.COMPONENT_GROUP_ALLOW_REFINEMENT__DATA_ASSET ||
			reference == TmdslPackage.Literals.COMPONENT_PART_ALLOW_REFINEMENT__DATA_ASSET
		) {
			//get all data types defined in the parent context
			val restriction = context.eContainer as PreventGroupRestrictionImpl
			val availableData = new ArrayList<DataType>
			val availabelDataGroupsIt = restriction.groupAsset.iterator
			while (availabelDataGroupsIt.hasNext){
				val dataGroup = availabelDataGroupsIt.next
				availableData.addAll(dataGroup.groupedData)
			}
			return Scopes.scopeFor(availableData)
			
		}
		
		/////////////////
		//ALLOW RESTRICIONTS
		//return data types for allow restrictions
		if (reference == TmdslPackage.Literals.COMPONENT_PREVENT_REFINEMENT__DATA_ASSET ||
			reference == TmdslPackage.Literals.COMPONENT_GROUP_PREVENT_REFINEMENT__DATA_ASSET ||
			reference == TmdslPackage.Literals.COMPONENT_PART_PREVENT_REFINEMENT__DATA_ASSET
		) {
			//get all data types defined in the parent context
			val restriction = context.eContainer as AllowGroupRestrictionImpl
			val availableData = new ArrayList<DataType>
			val availabelDataGroupsIt = restriction.groupAsset.iterator
			while (availabelDataGroupsIt.hasNext){
				val dataGroup = availabelDataGroupsIt.next
				availableData.addAll(dataGroup.groupedData)
			}
			return Scopes.scopeFor(availableData)
			
		}
		
		//get further parameters
		//since they are quite generic we use these cases for both ALLOW and PREVENT refinements
		
		if (reference == TmdslPackage.Literals.COMPONENT_ALLOW_REFINEMENT__COMPONENT ||
			reference == TmdslPackage.Literals.COMPONENT_PREVENT_REFINEMENT__COMPONENT
		){
			val components = EcoreUtil2.getAllContentsOfType(system, Component)
			return Scopes.scopeFor(components)
		}
		if (reference == TmdslPackage.Literals.COMPONENT_PART_ALLOW_REFINEMENT__COMPONENT_PART||
			reference == TmdslPackage.Literals.COMPONENT_PART_PREVENT_REFINEMENT__COMPONENT_PART
		){
			val componentParts = EcoreUtil2.getAllContentsOfType(system, ComponentPart)
			return Scopes.scopeFor(componentParts)
		}
		if (reference == TmdslPackage.Literals.COMPONENT_GROUP_ALLOW_REFINEMENT__COMPONENT_GROUP||
			reference == TmdslPackage.Literals.COMPONENT_GROUP_PREVENT_REFINEMENT__COMPONENT_GROUP
		){
			val componentGroups = EcoreUtil2.getAllContentsOfType(rootContainer, ComponentGroup)
			return Scopes.scopeFor(componentGroups)
		}
		if (reference == TmdslPackage.Literals.COMPONENT_GROUP_ALLOW_REFINEMENT__EXCLUDE_COMP) {
			val groupRefinement = context as ComponentGroupAllowRefinement
			val groups = groupRefinement.componentGroup
			val components = new ArrayList<Component>
			groups.forEach[group | components.addAll(group.groupedComponents)]
			val availableComponents = components.stream.distinct.collect(Collectors.toList())
			return Scopes.scopeFor(availableComponents)
		}
		if (reference == TmdslPackage.Literals.COMPONENT_GROUP_PREVENT_REFINEMENT__EXCLUDE_COMP) {
			val groupRefinement = context as ComponentGroupPreventRefinement
			val groups = groupRefinement.componentGroup
			val components = new ArrayList<Component>
			groups.forEach[group | components.addAll(group.groupedComponents)]
			val availableComponents = components.stream.distinct.collect(Collectors.toList())
			return Scopes.scopeFor(availableComponents)
		}
		if (reference == TmdslPackage.Literals.ALLOW_REFINEMENT_SANITIZER_OPTION__SANITIZER||
			reference == TmdslPackage.Literals.PREVENT_REFINEMENT_SANITIZER_OPTION__SANITIZER
		){
			val sanitizer = EcoreUtil2.getAllContentsOfType(rootContainer, Sanitizer)
			return Scopes.scopeFor(sanitizer)
			
		}



		
		

		
		if (context instanceof ComponentAssumption){

			//get scopes for all the restriction parameters
			if (reference == TmdslPackage.Literals.COMPONENT_ASSUMPTION__COMP) {
				val comps = EcoreUtil2.getAllContentsOfType(system, Component)
				return Scopes.scopeFor(comps)
			}
			if (reference == TmdslPackage.Literals.COMPONENT_ASSUMPTION__DATA){
				return Scopes.scopeFor(dataGroups)
			}
		}
		
		if (context instanceof ComponentSanitizerAssumption){
			//get scopes for all the restriction parameters
			if (reference == TmdslPackage.Literals.COMPONENT_SANITIZER_ASSUMPTION__SANITIZER_COMP) {
				val comps = EcoreUtil2.getAllContentsOfType(system, Component)
				return Scopes.scopeFor(comps)
			}
			if (reference == TmdslPackage.Literals.COMPONENT_SANITIZER_ASSUMPTION__SANITIZED_DATA){
				return Scopes.scopeFor(dataGroups)
			}
		}
				
		if (context instanceof ComponentFlowAssumption){
			val flowAssumption = context as ComponentFlowAssumption
			if (reference == TmdslPackage.Literals.COMPONENT_FLOW_ASSUMPTION__COMP) {
				val comps = EcoreUtil2.getAllContentsOfType(system,Component)
				return Scopes.scopeFor(comps)
			}
			if (reference == TmdslPackage.Literals.COMPONENT_FLOW_ASSUMPTION__SOURCE) {
				val comp = flowAssumption.comp
				return Scopes.scopeFor(comp.ports)
			}
			if (reference == TmdslPackage.Literals.COMPONENT_FLOW_ASSUMPTION__TARGET) {
				val comp = flowAssumption.comp
				val ports = new ArrayList(comp.ports)
				ports.remove(flowAssumption.source)
				return Scopes.scopeFor(ports)
			}
			if (reference == TmdslPackage.Literals.COMPONENT_FLOW_ASSUMPTION__DATA) {
				return Scopes.scopeFor(dataGroups)
			}
		}
		
		if (context instanceof ComponentFlowSanitizationAssumption){
			val flowAssumption = context as ComponentFlowSanitizationAssumption
			if (reference == TmdslPackage.Literals.COMPONENT_FLOW_SANITIZATION_ASSUMPTION__COMP) {
				val comps = EcoreUtil2.getAllContentsOfType(system,Component)
				return Scopes.scopeFor(comps)
			}
			if (reference == TmdslPackage.Literals.COMPONENT_FLOW_SANITIZATION_ASSUMPTION__SOURCE) {
				val comp = flowAssumption.comp
				return Scopes.scopeFor(comp.ports)
			}
			if (reference == TmdslPackage.Literals.COMPONENT_FLOW_SANITIZATION_ASSUMPTION__TARGET) {
				val comp = flowAssumption.comp
				val ports = new ArrayList(comp.ports)
				ports.remove(flowAssumption.source)
				return Scopes.scopeFor(ports)
			}
			if (reference == TmdslPackage.Literals.COMPONENT_FLOW_SANITIZATION_ASSUMPTION__SANITIZER) {
				val sans = EcoreUtil2.getAllContentsOfType(rootContainer, Sanitizer)
				return Scopes.scopeFor(sans)
			}
			if (reference == TmdslPackage.Literals.COMPONENT_FLOW_SANITIZATION_ASSUMPTION__DATA) {
				return Scopes.scopeFor(dataGroups)
			}
		}
		
		if (context instanceof PortPart) {
			if (reference == TmdslPackage.Literals.PORT_PART__PORT) {
				
				val parentPart = context.eContainer as ComponentPart
				//println(parentPart)
				val availablePorts = parentPart.component.ports
				return Scopes.scopeFor(availablePorts)
			}
		}
		if (context instanceof PortAssumption) {
			if (reference == TmdslPackage.Literals.PORT_ASSUMPTION__DATA) {
				return Scopes.scopeFor(dataGroups)
			}
			if (reference == TmdslPackage.Literals.PORT_ASSUMPTION__PORT) {
				return Scopes.scopeFor(EcoreUtil2.getAllContentsOfType(system, Port))
			}
		}
		
		if (context instanceof PortSanitizerAssumption) {
			if (reference == TmdslPackage.Literals.PORT_SANITIZER_ASSUMPTION__SANITIZED_DATA) {
				return Scopes.scopeFor(dataGroups)
			}
			if (reference == TmdslPackage.Literals.PORT_SANITIZER_ASSUMPTION__SANITIZER_PORT) {
				return Scopes.scopeFor(EcoreUtil2.getAllContentsOfType(system, Port))
			}
			if (reference == TmdslPackage.Literals.PORT_SANITIZER_ASSUMPTION__SANITIZER) {
				val sans = EcoreUtil2.getAllContentsOfType(rootContainer, Sanitizer)
				return Scopes.scopeFor(sans)
			}
		}
		
		
		if (context instanceof ComponentKind) {
			if (reference == TmdslPackage.Literals.COMPONENT_KIND__EXTENDS) {
				val componentKinds = new ArrayList(system.componentKinds)
				componentKinds.remove(context)
				return Scopes.scopeFor(componentKinds)
			}
		}
		
		
		super.getScope(context, reference)
		
	}
	
}
