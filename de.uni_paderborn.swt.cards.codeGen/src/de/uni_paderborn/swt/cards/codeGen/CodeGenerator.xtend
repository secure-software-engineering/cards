package de.uni_paderborn.swt.cards.codeGen

import de.uni_paderborn.swt.cards.dsl.tmdsl.CompositeComponent
import de.uni_paderborn.swt.cards.dsl.tmdsl.AtomicComponent
import java.util.ArrayList
import de.uni_paderborn.swt.cards.dsl.tmdsl.Component
import de.uni_paderborn.swt.cards.codeGen.classes.GenericINOUTPortGenerator
import de.uni_paderborn.swt.cards.codeGen.classes.GenericINPortGenerator
import de.uni_paderborn.swt.cards.codeGen.classes.GenericOUTPortGenerator
import java.io.File
import java.io.FileWriter
import de.uni_paderborn.swt.cards.codeGen.classes.AbstractAtomicComponentGenerator
import de.uni_paderborn.swt.cards.codeGen.classes.AbstractComponentGenerator
import de.uni_paderborn.swt.cards.codeGen.classes.AbstractCompositeComponentGenerator
import de.uni_paderborn.swt.cards.dsl.tmdsl.Assumption

class CodeGenerator {
	
	static def generate(String srcFolder, String srcGenFolder, String packageName, CompositeComponent parentCompositeComponent, Assumption assumption) {
		val packagePath = packageName.split("\\.").stream.reduce[a,b | a + File.separator + b].get;
		var classesPackage = packageName+".classes";
		val implPackage = packageName + ".impl";
			
		// generate abstract base classes
		generateClasses(srcGenFolder, classesPackage)
			
			
		// generate abstract components
		val alreadyGenerated = new ArrayList<Component>();
		val componentsToGenerate = new ArrayList<Component>();
		componentsToGenerate.add(parentCompositeComponent)
		
		while(componentsToGenerate.size > 0) {
			val c = componentsToGenerate.get(0);
			componentsToGenerate.remove(0);
			alreadyGenerated.add(c);
			
			if (c instanceof CompositeComponent) {
				val dirPath = srcGenFolder + File.separator + packagePath + File.separator;
				val fileName = "Abstract" + c.name.toFirstUpper + "_CC" + ".java";
				val content = new CompositeComponentGenerator().generate(packageName, classesPackage, c as CompositeComponent, assumption);
				
				writeToFile(dirPath, fileHeader(true).toString + content, fileName, true)

				val cc = c as CompositeComponent;
				for (cp : cc.componentParts) {
					if (!alreadyGenerated.contains(cp.component)) {
						componentsToGenerate.add(cp.component)
					}
				}	
			} else {
				val dirPath = srcGenFolder + File.separator + packagePath + File.separator;
				val fileName = "Abstract" + c.name.toFirstUpper + "_AC" + ".java";
				val content = new AtomicComponentGenerator().generate(packageName, classesPackage, c as AtomicComponent, assumption);
				
				writeToFile(dirPath, fileHeader(true).toString + content, fileName, true)
			}		
		}
		
		// generate example impl
		generateExampleImpl(srcFolder, implPackage, packageName, parentCompositeComponent, assumption)

	}
	
	def static generateExampleImpl(String srcFolder, String implPackage, String packageName, CompositeComponent parentCompositeComponent, Assumption assumption) {
		val packagePath = implPackage.split("\\.").stream.reduce[a,b | a + File.separator + b].get;
		
		val alreadyGenerated = new ArrayList<Component>();
		val componentsToGenerate = new ArrayList<Component>();
		componentsToGenerate.add(parentCompositeComponent)
		
		while(componentsToGenerate.size > 0) {
			val c = componentsToGenerate.get(0);
			componentsToGenerate.remove(0);
			alreadyGenerated.add(c);
			
			if (c instanceof CompositeComponent) {
				val dirPath = srcFolder + File.separator + packagePath + File.separator;
				val fileName = c.name.toFirstUpper + "_CC" + ".java";
				val content = new ImplCompositeComponentGenerator().generate(implPackage, packageName, c as CompositeComponent, assumption);
				
				writeToFile(dirPath, fileHeader(false).toString + content, fileName, false)

				val cc = c as CompositeComponent;
				for (cp : cc.componentParts) {
					if (!alreadyGenerated.contains(cp.component)) {
						componentsToGenerate.add(cp.component)
					}
				}	
			} else {
				val dirPath = srcFolder + File.separator + packagePath + File.separator;
				val fileName = c.name.toFirstUpper + "_AC" + ".java";
				val content = new ImplAtomicComponentGenerator().generate(implPackage, packageName, c as AtomicComponent, assumption);
				
				writeToFile(dirPath, fileHeader(false).toString + content, fileName, false)
			}		
		}
	}
	
	/**
	 * Make gen file header
	 */
	 private static def fileHeader(boolean replace) {
	 	'''
	 		/*
	 		* Generated by TMDSL codeGen version 1.0.0
	 		«IF replace»* Do not edit this code, as it might get overwritten by the generator.«ENDIF»
	 		«IF !replace»* You can edit this code, as it will not be overwritten.«ENDIF»
	 		*/
	 		
	 	'''
	 }
		
	/**
	 * Generate all abstract base classes
	 */
	private static def generateClasses(String location, String classesPackage) {
		val packagePath = classesPackage.split("\\.").stream.reduce[a,b | a + File.separator + b].get;
		
		var dirPath = location + File.separator + packagePath + File.separator;
		var fileName = "GenericINOUTPort.java";
		var content = GenericINOUTPortGenerator.generate(classesPackage);
		writeToFile(dirPath, content, fileName, true);
		
		dirPath = location + File.separator + packagePath + File.separator;
		fileName = "GenericINPort.java";
		content = GenericINPortGenerator.generate(classesPackage);	
		writeToFile(dirPath, content, fileName, true);
		
		dirPath = location + File.separator + packagePath + File.separator;
		fileName = "GenericOUTPort.java";
		content = GenericOUTPortGenerator.generate(classesPackage);	
		writeToFile(dirPath, content, fileName, true);	
		
		dirPath = location + File.separator + packagePath + File.separator;
		fileName = "AbstractAtomicComponent.java";
		content = AbstractAtomicComponentGenerator.generate(classesPackage);		
		writeToFile(dirPath, content, fileName, true);
		
		dirPath = location + File.separator + packagePath + File.separator;
		fileName = "AbstractComponent.java";
		content = AbstractComponentGenerator.generate(classesPackage);		
		writeToFile(dirPath, content, fileName, true);
		
		dirPath = location + File.separator + packagePath + File.separator;
		fileName = "AbstractCompositeComponent.java";
		content = AbstractCompositeComponentGenerator.generate(classesPackage);		
		writeToFile(dirPath, content, fileName, true);
	}
	
	/**
	 * Write content to file
	 */
	private static def writeToFile(String directory, CharSequence content, String fileName, boolean replace) {
		val d = new File(directory);
		d.mkdirs
		
		val filePath = directory + File.separator + fileName;
		val f = new File(filePath);
		if (f.exists && replace) {
			f.delete()
		}
		if (!f.exists) {
			f.createNewFile();
			val fw = new FileWriter(f);
			fw.append(content)
			fw.flush
			fw.close				
		}
	}
}