/*
 * generated by Xtext 2.18.0.M3
 */
package de.uni_paderborn.swt.cards.dsl.validation

import de.uni_paderborn.swt.cards.dsl.analyzer.Analyzer
import de.uni_paderborn.swt.cards.dsl.analyzer.data.RestrictionViolation
import de.uni_paderborn.swt.cards.dsl.tmdsl.AllowGroupRestriction
import de.uni_paderborn.swt.cards.dsl.tmdsl.Component
import de.uni_paderborn.swt.cards.dsl.tmdsl.ComponentPart
import de.uni_paderborn.swt.cards.dsl.tmdsl.CompositeComponent
import de.uni_paderborn.swt.cards.dsl.tmdsl.DataType
import de.uni_paderborn.swt.cards.dsl.tmdsl.Model
import de.uni_paderborn.swt.cards.dsl.tmdsl.PreventGroupRestriction
import de.uni_paderborn.swt.cards.dsl.tmdsl.TmdslPackage
import java.util.ArrayList
import java.util.List
import java.util.stream.Collectors
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class TMDslValidator extends AbstractTMDslValidator {
	
	@Check(FAST)
	def checkCircularCompositeContainment(CompositeComponent c) {
		if (Analyzer.checkCompositeForLoops(c)) {
			error("CompositeComponent " + c.name + " must not contain itself", TmdslPackage.Literals.COMPOSITE_COMPONENT__COMPONENT_PARTS);
		}
	}
	
	@Check(NORMAL)
	def checkRestrictions(Component c) {

		val model = findModel(c);
		if (objectHasViolation(model, c)) {
			for (rv : getViolationsForObject(model, c)) {

				error(rv.toString(), TmdslPackage.Literals.COMPONENT__NAME)
			}
		}
	}

	@Check(NORMAL)
	def checkRestrictions(ComponentPart c) {

		val model = findModel(c);
		if (objectHasViolation(model, c)) {

			for (rv : getViolationsForObject(model, c)) {

				error(rv.toString(), TmdslPackage.Literals.COMPONENT_PART__NAME)
			}
		}
	}

	/**
	 * Checks whether a securityLevel is between 0 and 255
	 */
	@Check(FAST)
	def checkSecurityLevelShort(Component c) {
		if (c.securityLevel < 0 || c.securityLevel > 255) {
			warning("The security level for component " + c.name +" should be a value between 0 and 255",
				TmdslPackage.Literals.COMPONENT__SECURITY_LEVEL)
		}
	}

	/**
	 * Checks whether a datytype is 
	 * <p>a) in at least one restriction</p>
	 * <p>b) not in contradictary restrictions</p>
	 * 
	 */
	@Check(FAST)
	def checkEachDataTypeIsRestricted(DataType d) {

		val model = findModel(d)

		val restriction = model.restriction
		val allowGroupRestrictions = restriction.restrictions.filter[res|res instanceof AllowGroupRestriction]
		val preventGroupRestrictions = restriction.restrictions.filter[res|res instanceof PreventGroupRestriction]

		var allowed = 0
		var forbidden = 0

		for (agr : allowGroupRestrictions) {
			for (dataGroup : (agr as AllowGroupRestriction).groupAsset) {
				if (dataGroup.groupedData.contains(d)) {
					allowed += 1
				}
			}
		}

		for (pgr : preventGroupRestrictions) {
			for (dataGroup : (pgr as PreventGroupRestriction).groupAsset) {
				if (dataGroup.groupedData.contains(d)) {
					forbidden += 1
				}
			}
		}

		if (!(allowed > 0 || forbidden > 0)) {
			// neither allowed nor forbidden
			warning("The data type "+ d.name + " should be either globally allowed or prevented",
				TmdslPackage.Literals.DATA_TYPE__NAME)
		}

		if (allowed > 0 && forbidden > 0) {
			// contradiction
			error("The data type "+ d.name + " must not be both allowed and prevented",
				TmdslPackage.Literals.DATA_TYPE__NAME)
		}
		
		if ((allowed > 1 && forbidden == 0) || (allowed == 0 && forbidden > 1)) {
			warning("The data type "+ d.name + " is defined in more than one (non contradictory) restriction. This can lead to unexpected behaviour",
				TmdslPackage.Literals.DATA_TYPE__NAME)
		}
	}

	/**
	 * For a given EObject, return the model container or null, if there is none.
	 * Recreates the <p>eobj.ancestors() -> filter(tmdsl::Model)</p> behaviour of sirius/aql
	 * @param obj Child Object
	 */
	private def findModel(EObject obj) {

		var model = null as Model;
		var e = obj

		while (e !== null && model === null) {
			//println(e)
			if (e instanceof Model) {
				model = e as Model
			} else {
				e = e.eContainer()
			}
		}
		return model
	}

	def boolean objectHasViolation(Model model, EObject c) {
		// only show if its for the component, not if its for a component part?
		val List<RestrictionViolation> violations = analysis.getViolations(model);
		
		val ancestors = ancestorsWithoutModel(c);
		if (c instanceof ComponentPart) {
			ancestors.add((c as ComponentPart).component)
		}
		for (RestrictionViolation rv : violations) {
			val s = rv.stack
			if (s.containsAll(ancestors) && ancestors.containsAll(s)) {
				return true;
			}

		}

		return false;
	}

	val analysis = new AnalysisSingleton();

	def List<RestrictionViolation> getViolationsForObject(Model model, EObject c) {
		var violations = analysis.getViolations(model);
		val list = new ArrayList<RestrictionViolation>();
		val ancestors = ancestorsWithoutModel(c);
		if (c instanceof ComponentPart) {
			ancestors.add((c as ComponentPart).component)
		}
		
		for (rv : violations) {			
			
			val s = rv.stack
			if (s.containsAll(ancestors) && ancestors.containsAll(s)) {
				list.add(rv);
			}
		}

		return list;
	}
	
	def private static List<EObject> ancestors(EObject obj) {
		val ancestors = new ArrayList<EObject>();
		var c = obj
		while (c !== null) {
			ancestors.add(c);
			c = c.eContainer();
		}
		return ancestors;
	}
	
	def private static List<EObject> ancestorsWithoutModel(EObject obj) {
		val list = ancestors(obj);
		return list.stream().filter[o | !(o instanceof Model)].collect(Collectors.toList());
	}
}
